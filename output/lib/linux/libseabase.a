!<arch>
//                                              90        `
xEcharacterCode.cpp/
xDemultiplexerSelect.cpp/
xEventDemultiplexer.cpp/
xEthreadpool.cpp/
xtimeheap.cpp/  0           0     0     644     2812      `
#include "xtimeheap.h"
#include "xTimeuil.h"
using namespace SEABASE;
void xtime_heap::percolate_down(int hole)
{
	xheaptimer* temp = array[hole];
	int child=0;
	for(;((hole*2+1)<=(m_cur_size-1));hole=child)
	{
		child=hole*2+1;
		if(child<(m_cur_size-1)&& (array[child+1]->expire < array[child]->expire))
		{
			child++; //å­èŠ‚ç‚¹ä¸­è¾ƒå°çš„å…ƒç´ 
		}
		if(array[child]->expire < temp->expire)
		{
			array[hole] = array[child]; //å¦‚æœè¾ƒå°çš„å­èŠ‚ç‚¹å°äºæ ¹èŠ‚ç‚¹ï¼Œåˆ™ä¸Šæ—‹ã€‚
		}
		else
		{
			break;
		}
		//array[hole] = temp;

	}
	array[hole] = temp;// åœ¨åšå°æ ¹å¯¹è°ƒæ•´æ—¶ï¼Œæœ€åèµ‹å€¼ã€‚
}
void xtime_heap::resize() throw (std::exception)
{
	xheaptimer**temp = new xheaptimer*[2*m_capacity];
	for(int i=0;i<2*m_capacity;++i)
	{
		temp[i]=NULL;
	}
	if(!temp)throw std::exception();
	int temp_cap=2*m_capacity;
	for (int i=0;i<m_cur_size;++i)
	{
		temp[i] = array[i];
	}
	delete [] array;
	array=temp;
}
void xtime_heap::add_timer(xheaptimer*timer)throw(std::exception)
{
	if(!timer)
	{
		return ;
	}
	if(m_cur_size >= m_capacity)
	{
		resize();
	}
	int hole=m_cur_size++;
	int parent=0;
	//å°†æ–°åŠ å…¥çš„å…ƒç´ æ”¾åœ¨æœ€åé¢ï¼Œç„¶åä¸Šæ—‹è°ƒæ•´ã€‚
	for(;hole>0;hole=parent)
	{
		parent = (hole-1)/2;
		if(array[parent]->expire <= timer->expire)
		{
			break;
		}
		array[hole]=array[parent];
	}
	array[hole]=timer;
}
void xtime_heap::del_timer(xheaptimer* timer)
{
	if(!timer)
	{
		return;
	}
	//è¿™é‡Œå°†å®šæ—¶å™¨çš„ç›¸åº”æ¥å£ç»™ç½®ä¸ºç©ºï¼Œè¿˜æ²¡æœ‰ä»é˜Ÿåˆ—åˆ é™¤
	timer->cb_func = NULL;
	//pop_timer()
}
xheaptimer * xtime_heap::top()const 
{
	if(empty())
		return NULL;
	return array[0];
}
void xtime_heap::pop_timer()
{
	if(empty())
		return;
	if(array[0])
	{
		//å°†æœ€åé¢çš„å…ƒç´ æ”¾åœ¨ç¬¬ä¸€ä½ï¼Œç„¶åå‘ä¸‹è°ƒæ•´å°æ ¹å †
		//delete array[0];
		//åœ¨å‡ºé˜Ÿåˆ—çš„æ—¶å€™ï¼Œç›´æ¥å°†æŒ‡é’ˆæŒ‡å‘åˆ«çš„åœ°æ–¹ï¼Œä¸åšåˆ é™¤ã€‚å¦‚æœæ˜¯å¯¹è±¡ï¼Œåˆ™ç»“æŸè‡ªåŠ¨é‡Šæ”¾
		//å¦‚æœæ˜¯newçš„å†…å­˜ï¼Œç”±å¤–éƒ¨é‡Šæ”¾ã€‚
		array[0]=array[--m_cur_size];
		percolate_down(0);
		array[m_cur_size]=NULL;
	}
}
void xtime_heap::tick()
{
	xheaptimer* temp=array[0];
	time_t cur = time(NULL);
	while(!empty())
	{
		if(!temp)
		{
			break;
		}
		if(temp->expire >cur)
			break;
		if(array[0]->cb_func)
		{
			array[0]->cb_func(array[0]->user_data);
		}
		pop_timer();
		temp=array[0];
	}
}
void xtime_heap::tick_ms(vector<xheaptimer*>&listofdelete)
{
	xheaptimer* temp=array[0];
	time_t cur = xTimeUtil::get_timestamp_ms();
	while(!empty())
	{
		if(!temp)
		{
			break;
		}
		if(temp->expire >cur)
			break;
		if(array[0]->cb_func)
		{
			array[0]->cb_func(array[0]->user_data);
		}
		pop_timer();
		listofdelete.push_back(temp);
		temp=array[0];
	}
}xEFile.cpp/     0           0     0     644     6993      `
//2019-7-31 xjshi
#include "../include/xEFile.h"
using namespace SEABASE;
#include <fstream>
#include <iostream>
#ifdef WIN32

#include <direct.h>
#include <io.h>
#else
#include <sys/stat.h>
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <dirent.h>
#endif
bool xEFile::MakePath(const string& path)
{
#ifdef WIN32
     return (0 == _mkdir(path.c_str()));
#else
     return (0==mkdir(path.c_str(),0777));
#endif
}

        //¸´ÖÆÎÄ¼ş
        //²ÎÊı£ºsourceFile Ô´ÎÄ¼ş
        //      destFle    Ä¿±êÎÄ¼şÃû³Æ
        //     overwrite   ÊÇ·ñ¸²¸Ç
bool xEFile::Copy(const string& sourceFile, const string& destFile, bool overwrite )
{
#ifdef WIN32
    if (!canRead(sourceFile))
    {
        //Ô´ÎÄ¼ş²»´æÔÚ»ò²»¿É¶Á
        return false;
    }
    if (overwrite && Exists(destFile))
    {
        //Ä¿±êÎÄ¼ş´æÔÚ
        if (!canWrite(destFile))
        {
            //²»¿ÉĞ´
            return false;
        }
    }
    //¶ÁÎÄ¼şÁ÷
    fstream readStream;
    //Ğ´ÎÄ¼şÁ÷
    fstream writeStream;
    readStream.open(sourceFile.c_str(), ios_base::in|ios_base::binary);
    writeStream.open(destFile.c_str(), ios_base::out|ios_base::binary);
    char currentChar = 0;
    while (!readStream.eof())
    {
        readStream.get(currentChar);
        if (!readStream.eof())
        {
            writeStream << currentChar;
        }					
    }
    readStream.close();
    writeStream.close();
    return true;
#else 
    if (!canRead(sourceFile))
    {
        //Ô´ÎÄ¼ş²»´æÔÚ»ò²»¿É¶Á
        return false;
    }
    if (overwrite && Exists(destFile))
    {
        //Ä¿±êÎÄ¼ş´æÔÚ
        if (!canWrite(destFile))
        {
            //²»¿ÉĞ´
            return false;
        }
    }
    //¶ÁÎÄ¼şÁ÷
    fstream readStream;
    //Ğ´ÎÄ¼şÁ÷
    fstream writeStream;
    readStream.open(sourceFile.c_str(), ios_base::in|ios_base::binary);
    writeStream.open(destFile.c_str(), ios_base::out|ios_base::binary);
    char currentChar = 0;
    while (!readStream.eof())
    {
        readStream.get(currentChar);
        if (!readStream.eof())
        {
            writeStream << currentChar;
        }					
    }
    readStream.close();
    writeStream.close();
    return true;
#endif
}
       
bool xEFile::Exists(const string& filename)
{
#ifdef WIN32
            return (0 == _access(filename.c_str(), 0));
#else
            return (0 == access(filename.c_str(), 0));
#endif
}

bool xEFile::Remove(const string& filename)
{
    if (!Exists(filename))
    {
        //²»´æÔÚ
        return false;
    }
#ifdef WIN32
    return (0 == _unlink(filename.c_str()));
#else
    return (0 == unlink(filename.c_str()));
#endif
}

bool xEFile::move(const string& sourceFile, const string& destFile)
{
#ifdef WIN32
    return (0 == rename(sourceFile.c_str(), destFile.c_str()));
#else
//½ö¿ÉÒÆ¶¯ÎÄ¼ş
    return (0 == rename(sourceFile.c_str(), destFile.c_str()));
#endif
}

bool xEFile::canRead(const string& path)
{
    if (!Exists(path))
    {
        //ÎÄ¼ş²»´æÔÚ
        return false;
    }
#ifdef WIN32
    if (0 == _access(path.c_str(), 4))
    {
        //read only
        return true;
    }
    if (0 == _access(path.c_str(), 6))
    {
        //read write
        return true;
    }
#else
    if (0 == access(path.c_str(), 4))
    {
        //read only
        return true;
    }
    if (0 == access(path.c_str(), 6))
    {
        //read write
        return true;
    }
#endif
    return false;
}


bool xEFile::canWrite(const string& path)
{
    if (!Exists(path))
    {
        //ÎÄ¼ş²»´æÔÚ
        return false;
    }
#ifdef WIN32
    if (0 == _access(path.c_str(), 2))
    {
        //read only
        return true;
    }
    if (0 == _access(path.c_str(), 6))
    {
        //read write
        return true;
    }
#else
    if (0 == access(path.c_str(), 2))
    {
        //read only
        return true;
    }
    if (0 == access(path.c_str(), 6))
    {
        //read write
        return true;
    }
#endif
    return false;
}

        //»ñÈ¡ÎÄ¼ş´óĞ¡
        //²ÎÊı£ºpath  ÎÄ¼şÂ·¾¶
        //·µ»ØÖµ£º ·µ»Ø´óĞ¡£¬Îª0Ôò²»´æÔÚ
int xEFile::GetFileSize(const string &path)
{
    if (!Exists(path))
    {
        return 0;
    }
#if 0
#ifdef WIN32
    struct _stat status;
    if (0 == _stat(path.c_str(), &status))
    {
        //»ñÈ¡³É¹¦
        return status.st_size;
    }
    else{
        //»ñÈ¡Ê§°Ü
        return 0;
    }
#else

    struct stat status;
    if (0 == stat(path.c_str(), &status))
    {
        //»ñÈ¡³É¹¦
        return status.st_size;
    }
    else{
        //»ñÈ¡Ê§°Ü
        return 0;
    }
#endif

#endif
    return 0;
}

        //ËÑË÷·ûºÏÌõ¼şµÄÎÄ¼ş
        //²ÎÊı£º contidion  ËÑË÷Ìõ¼ş Èç"c:/windows/*.*"
        //       files     ·ûºÏÌõ¼şµÄÎÄ¼şÃû¼¯ºÏ£¬²»´øÂ·¾¶
        //·µ»ØÖµ£ºÈç¹û´æÔÚ·ûºÏÌõ¼şµÄÎÄ¼ş£¬·µ»Øture,·ñÔò·µ»Øfalse
bool xEFile::search(const string& condition, vector< string >& files)
{
#ifdef WIN32
    struct _finddata_t file_data;
    intptr_t hFile;
    hFile = _findfirst(condition.c_str(), &file_data);
    if ( -1L == hFile)
    {
        //Ã»ÓĞÆ¥ÅäÎÄ¼ş
        return false;
    }
    do{
        //±éÀúËùÓĞÎÄ¼ş
        files.push_back(file_data.name);
    }
    while (0 == _findnext(hFile, &file_data));
    _findclose(hFile);
    if (0 != files.size())
    {
        return true;
    }
    else{
        return false;
    }
#else
    struct dirent *dp;
    DIR *dfd = NULL;

    //×îºóµÄ¡®/¡¯
    const int pos = condition.find_last_of('/')+1;
    //Ä¿Â¼
    const string dir = condition.substr(0, pos);
    //ÎÄ¼ş
    const string file = condition.substr(pos, condition.size());

    //ÎÄ¼şÀàĞÍ
    string fileType("");
    //°üº¬¡°.¡±
    if(string::npos != file.find('.'))
    {
        fileType = condition.substr(file.find_last_of('.')+1, file.size());
    }
    else
    {
        fileType = file;
    }

    //´ò¿ªÄ¿Â¼
    if((dfd = opendir(dir.c_str())) == NULL)
    {
        return false;
    }
    //ÂÖÑ¯Ä¿Â¼ÏÂµÄÎÄ¼ş
    for(dp = readdir(dfd); NULL!=dp; dp = readdir(dfd))
    {
        if(dp->d_type == 4 || dp->d_type == 10)// dir/link file
        {
            //		continue;
            string fileName(dp->d_name);
            files.push_back(fileName);
        }
        else if(dp->d_type == 8)//file
        {
            string fileName(dp->d_name);
            if((0 == file.compare("*")) || (0 == file.compare("*.*")))
            {
                //²»´øÂ·¾¶µÄÎÄ¼şÃû
                files.push_back(fileName);
            }
            else if(string::npos != fileName.find(fileType))
            {
                //²»´øÂ·¾¶µÄÎÄ¼şÃû
                files.push_back(fileName);
            }
        }

    }
    closedir(dfd);
    return true;
//}
#endif
    return true;
}
/0              0           0     0     644     4062      `
#include "../include/xEcharacterCode.h"
#ifdef WIN32
#include <Windows.h>
#include <tchar.h>
#else
#include<dlfcn.h>
#include <iconv.h>
#endif
#include<string.h>
#include<stdio.h>
#include<errno.h>
using namespace std;

using namespace SEABASE;

int CharacterCode::GetCharacterTpye()
{
    return 0;
}
string CharacterCode::Gb2312ToUTF_8(char* gb2312)
{
#ifdef WIN32
    int len=MultiByteToWideChar(CP_ACP,0,gb2312,-1,NULL,0);
    wchar_t*wstr=new wchar_t[len+1];
    memset(wstr,0,len+1);
    MultiByteToWideChar(CP_ACP,0,gb2312,-1,wstr,len);
    len=WideCharToMultiByte(CP_UTF8,0,wstr,-1,NULL,0,NULL,NULL);
    char*str=new char[len+1];
    memset(str,0,len+1);
    WideCharToMultiByte(CP_UTF8,0,wstr,-1,str,len,NULL,NULL);
    if(wstr)delete[] wstr;
    string strtemp(str,strlen(str));
    if(str) delete[] str;
    return strtemp;
#else
    iconv_t cd;
    char **pin = &gb2312;
    size_t src_len=strlen(gb2312);
    cd = iconv_open("utf8", "gbk");
    if (cd == 0)
        return "";
    size_t dst_len=2*src_len+1;
    char *dst_str=new char[dst_len];
    char*out=dst_str;
    memset(dst_str, 0, dst_len);
	int ret = iconv(cd, pin, &src_len, &out, &dst_len);
	printf("ret=%d,erron=%d\n",ret,errno);
	printf("out=%s\n",out);
	switch(errno)
	{
	case  E2BIG:
		printf("E2BIG\n");
	case  EILSEQ:
		printf("EILSEQ\n");
	case  EINVAL:
		printf("EINVAL\n");
	}
    if (ret == -1)
        return "";
    iconv_close(cd);
    string strtemp(dst_str,strlen(dst_str));
    delete[] dst_str;
    return strtemp;
#endif
}
string CharacterCode::UTF_8ToGb2312(const char* utf8)
{
#ifdef WIN32
	int len = MultiByteToWideChar(CP_UTF8, 0, utf8, -1, NULL, 0);
	wchar_t* wstr = new wchar_t[len+1];
	memset(wstr, 0, len+1);
	MultiByteToWideChar(CP_UTF8, 0, utf8, -1, wstr, len);
	len = WideCharToMultiByte(CP_ACP, 0, wstr, -1, NULL, 0, NULL, NULL);
	char* str = new char[len+1];
	memset(str, 0, len+1);
	WideCharToMultiByte(CP_ACP, 0, wstr, -1, str, len, NULL, NULL);
	if(wstr) delete[] wstr;
	return str;
#else
	iconv_t cd;
	char **pin = (char**)&utf8;
	size_t src_len=strlen(utf8);
	cd = iconv_open("gbk", "utf8");
	if (cd == 0)
		return "";
	size_t dst_len=2*src_len+1;
	char *dst_str=new char[dst_len];
	char*out=dst_str;
	memset(dst_str, 0, dst_len);
	if (iconv(cd, pin, &src_len, &out, &dst_len) == -1)
		return "";
	iconv_close(cd);
	string strtemp(dst_str,strlen(dst_str));
	delete[] dst_str;
	return strtemp;
#endif
}
void CharacterCode::Ascii2BCD( char *bcd_buf, char *asc_buf,int num)
{
    int     i, len;

    len = num / 2 ;
    for ( i=0; i<len; i++)
    {
        if (asc_buf[i * 2 + 0] >= '0' && asc_buf[i * 2 + 0] <= '9')
        {
            bcd_buf[i] = (asc_buf[i * 2 + 0] - 48) * 16 ;
        }
        if (asc_buf[i * 2 + 0] >= 'A' && asc_buf[i * 2 + 0] <= 'Z')
        {
            bcd_buf[i] = (asc_buf[i * 2 + 0] - 'A' + 10) * 16 ;
        }
        if (asc_buf[i * 2 + 0] >= 'a' && asc_buf[i * 2 + 0] <= 'z')
        {
            bcd_buf[i] = (asc_buf[i * 2 + 0] - 'a' + 10) * 16 ;
        }

        if (asc_buf[i * 2 + 1] >= '0' && asc_buf[i * 2 + 1] <= '9')
        {
            bcd_buf[i] += (asc_buf[i * 2 + 1] - 48)  ;
        }
        if (asc_buf[i * 2 + 1] >= 'A' && asc_buf[i * 2 + 1] <= 'Z')
        {
            bcd_buf[i] += (asc_buf[i * 2 + 1] - 'A' + 10)  ;
        }
        if (asc_buf[i * 2 + 1] >= 'a' && asc_buf[i * 2 + 1] <= 'z')
        {
            bcd_buf[i] += (asc_buf[i * 2 + 1] - 'a' + 10)  ;
        }
    }
}
    //		bcd_buf[i]=((asc_buf[2*i] & 0x0f) << 4)+(asc_buf[2*i+1] & 0x0f);

	//Õ­×Ö·û×ª¿í×Ö·û
	wchar_t* CharacterCode::AnsiToUnicode(const char* szStr)
{
#ifdef WIN32
		int nLen = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szStr, -1, NULL, 0 );

		if (nLen == 0)
		{
			return NULL;
		}
		wchar_t* pResult = new wchar_t[nLen];
		MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szStr, -1, pResult, nLen );
		return pResult;
#else
#endif
	return NULL;

	}
/21             0           0     0     644     1791      `
//xjshi 2019/3/13
//ÖØ¹¹hpp
#include"xDemultiplexerSelect.h"
using namespace SEABASE;

//select
#ifdef WIN32
xSelectDemultiplexer::xSelectDemultiplexer()
{
	m_fd_num=0;
	FD_ZERO(&m_fdReadSave);
}
xSelectDemultiplexer::~xSelectDemultiplexer()
{

}

int xSelectDemultiplexer::WaitEvents(int timeout,xtime_heap* event_timer )
{
	//std::vector<handle_t> m_Readevents;
	fd_set fdread;
	FD_ZERO(&fdread);
	memcpy(&fdread,&m_fdReadSave,sizeof(m_fdReadSave));
	timeval timev_;
	timev_.tv_sec=timeout/1000;
	timev_.tv_usec=0;
	int res = select( 0,  &fdread , NULL,NULL, &timev_);
	if(res>0)
	{

		for(int j=0;j<m_fdReadSave.fd_count;j++)
		{
			int fd=m_fdReadSave.fd_array[j];
			if(FD_ISSET(fd,&fdread))
			{
				//m_handlers[fd]->HandleRead(fd,this);
				if(m_handlers[fd].m_readptr)
				{
					m_handlers[fd].m_readptr(fd,this,(void*)m_handlers[fd].m_readarg);
				}
			}
		}

	}
	if(event_timer !=NULL)
	{
		event_timer->tick();
	}
	return 0;
}
int xSelectDemultiplexer::RequestEvent(xEvent_t &e)
{
	int handle = e.m_Eventfd;
	std::map<handle_t,xEvent_t>::iterator it = m_handlers.find(handle);
	if(it==m_handlers.end())
	{
		m_handlers[handle]=e;
	}
	FD_SET((SOCKET)handle,&m_fdReadSave);
	if((int)handle > m_maxfdID)
		m_maxfdID = (int)handle +1;
	++m_fd_num;
	// 	if(evt & xWriteEvent)
	// 		FD_SET(handle,&m_fdread);
	// 	if(evt &xErrorEvent)
	// 		FD_SET(handle,&m_fdError);
	return 0;
}
int xSelectDemultiplexer::UnrequestEvent(SEABASE::handle_t handle)
{
	if((SOCKET)handle!=INVALID_SOCKET)
	{
		FD_CLR((SOCKET)handle,&m_fdReadSave);
		--m_fd_num;
		std::map<handle_t,xEvent_t>::iterator it = m_handlers.find(handle);
		if(it!=m_handlers.end())
		{
			m_handlers.erase(handle);
		}
	}
	return 0;
}

#endif
xStringuil.cpp/ 0           0     0     644     10358     `
/***********************************************************************
  * Copyright (c) 2012, Baidu Inc. All rights reserved.
  * 
  * Licensed under the BSD License
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  * 
  *      license.txt
  *********************************************************************/

#include <ctype.h>
#ifdef _WIN32
#define _CRT_RAND_S
#include <objbase.h>
#endif
#include <iostream>
#include <algorithm>

#include "xTimeuil.h"
#include "xStringuil.h"
/*#include "guard.h"*/

namespace SEABASE {

    void xStringUtil::toupper_inplace(char* str) {
        if (NULL == str) {
            return;
        }

        while ('\0' != *str) {
            *str = ::toupper(*str);
            ++str;
        }
    }

    std::string xStringUtil::toupper(const char* str) {
        if (NULL == str) {
            return "";
        }

        std::string tmp(str);
        std::transform(tmp.begin(), tmp.end(), tmp.begin(), ::toupper);
        return tmp;
    }

    std::string xStringUtil::toupper(const std::string& str) {
        return xStringUtil::toupper(str.c_str());
    }

    void xStringUtil::tolower_inplace(char* str) {
        if (NULL == str) {
            return;
        }

        while ('\0' != *str) {
            //note ÏÂĞĞtolowerÇ°µÄ::²»¿ÉÊ¡ÂÔ
            *str = ::tolower(*str);
            ++str;
        }
    }

    std::string xStringUtil::tolower(const char* str) {
        if (NULL == str) {
            return "";
        }

        std::string tmp(str);
        //note ÏÂĞĞtolowerÇ°µÄ::²»¿ÉÊ¡ÂÔ
        std::transform(tmp.begin(), tmp.end(), tmp.begin(), ::tolower);
        return tmp;
    }
	
    std::string xStringUtil::tolower(const std::string& str) {
        return xStringUtil::tolower(str.c_str());
    }

    void xStringUtil::ltrim_inplace(char* str) {
        if (NULL == str) {
            return;
        }

        char *pc = str;
        while (::isspace(*pc)) {
            ++pc;
        }

        if (pc != str) {
            while ((*str++ = *pc++)) {
            }
        }
    }

    std::string xStringUtil::ltrim(const char* str) {
        if (NULL == str) {
            return "";
        }

        const char *pc = str;
        while (::isspace(*pc)) {
            ++pc;
        }

        return std::string(pc);
    }

    std::string xStringUtil::ltrim(const std::string& str) {
        return xStringUtil::ltrim(str.c_str());
    }

    void xStringUtil::rtrim_inplace(char* str) {
        if (NULL == str) {
            return;
        }

        char *tail = str + strlen(str) - 1;
        while (tail >= str && ::isspace(*tail)) {
            *tail-- = '\0';
        }
    }

    std::string xStringUtil::rtrim(const char* str, int32_t len) {
        if (NULL == str || len <= 0) {
            return "";
        }

        const char* head = str;
        const char* tail = head + len - 1;

        while (tail >= head && ::isspace(*tail)) {
            --tail;
        }

        if (tail >= head) {
            return std::string(head, tail - head + 1); 
        }
        else {
            return "";
        }
    }

    std::string xStringUtil::rtrim(const char* str) {
        if (NULL == str) {
            return "";
        }
        else {
            return xStringUtil::rtrim(str, (int32_t)strlen(str));
        }
    }

    std::string xStringUtil::rtrim(const std::string& str) {
        return xStringUtil::rtrim(str.c_str(), (int32_t)str.size());
    }

    void xStringUtil::trim_inplace(char* str) {
        xStringUtil::ltrim_inplace(str);
        xStringUtil::rtrim_inplace(str);
    }

    std::string xStringUtil::trim(const char* str) {
        return xStringUtil::rtrim(xStringUtil::ltrim(str));
    }

    std::string xStringUtil::trim(const std::string& str) {
        return xStringUtil::rtrim(xStringUtil::ltrim(str));
    }

    void xStringUtil::split_string(const std::string& str, const std::string& separator,
            std::vector<std::string>& container, bool filter_empty) {
        std::string::size_type pos;
        std::string::size_type lastPos = 0;

        container.clear();

        while (true) {
            pos = str.find_first_of(separator, lastPos);
            if (pos == std::string::npos) {
                pos = str.length();

                if(pos != lastPos || false == filter_empty) {
                    container.push_back(std::string(str.data() + lastPos, pos - lastPos));
                }

                break;
            }
            else {
                if(pos != lastPos || false == filter_empty) {
                    container.push_back(std::string(str.data() + lastPos, pos - lastPos));
                }
            }

            lastPos = pos + 1;
        }
    }

    std::string xStringUtil::replace_string(const std::string& str, const std::string& target,
            const std::string& replacement) {
        std::string ret;
        std::string::size_type target_len = target.length();

        if (0 == target_len) {
            return str;
        }

        std::string::size_type pos_begin = 0;
        std::string::size_type pos_target = str.find(target, pos_begin);
        const char *str_head = str.data();

        while (pos_target != std::string::npos) {
            ret.append(str_head + pos_begin, pos_target - pos_begin);
            ret += replacement;
            pos_begin = pos_target + target_len;
            pos_target = str.find(target, pos_begin);
        }

        if (pos_begin < str.length()) {
            ret.append(str.begin() + pos_begin, str.end());
        }
        return ret;
    }
    bool xStringUtil::str2uint32(const char* str, uint32_t& number) {
#ifdef _WIN32

        std::string trimed = xStringUtil::ltrim(str);
        if (0 < trimed.length() && trimed.at(0) == '-') {
            return false;
        }
#endif
        return xStringUtil::str2integer(str, number);
    }

    bool xStringUtil::str2int32(const char* str, int32_t& number) {
        return xStringUtil::str2integer(str, number);
    }

    bool xStringUtil::str2uint64(const char* str, uint64_t& number) {
#ifdef _WIN32
        std::string trimed = xStringUtil::ltrim(str);
        if (0 < trimed.length() && trimed.at(0) == '-') {
            return false;
        }
#endif
        return xStringUtil::str2integer(str, number);
    }

    bool xStringUtil::str2int64(const char* str, int64_t& number) {
        return xStringUtil::str2integer(str, number);
    }

    std::string xStringUtil::generate_uuid() {
        char uuid[40] = {0};
#ifdef _WIN32
        GUID guid;
        CoCreateGuid(&guid);
        snprintf( uuid,
                sizeof(uuid),
                "%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
                guid.Data1, guid.Data2, guid.Data3,
                guid.Data4[0], guid.Data4[1],
                guid.Data4[2], guid.Data4[3],
                guid.Data4[4], guid.Data4[5],
                guid.Data4[6], guid.Data4[7]);
#else
		xGuard<xEmutex> guard(&stMutex);
        FILE* f = fopen("/proc/sys/kernel/random/uuid", "r");
        if (f != NULL) {
            fread(uuid, 1, 36, f);
            fclose(f);
        }
        else {
            return rand_string() + rand_string() + rand_string();
        }
#endif
        return uuid;
    }

    bool xStringUtil::ipv4_ntoa(uint32_t src, std::string& dest) {
        uint32_t a, b, c, d;
        char buffer[16] = {0};

        a = (src >> 24) & 0xff;
        b = (src >> 16) & 0xff;
        c = (src >> 8) & 0xff;
        d = src & 0xff;

        snprintf(buffer, 16, "%u.%u.%u.%u", a, b, c, d);

        dest = buffer;
        return true;
    }

    bool xStringUtil::ipv4_aton(const char* src, uint32_t& dest) {
        if (NULL == src) {
            return false;
        }

        uint32_t a, b, c, d;

        if (4 != sscanf(src, "%u.%u.%u.%u", &a, &b, &c, &d)) {
            return false;
        }

        if (a > 255 || b > 255 || c > 255 || d > 255) {
            return false;
        }

        dest = 0;
        dest |= a << 24;
        dest |= b << 16;
        dest |= c << 8;
        dest |= d;
        return true;
    }
	//////////////////////////////////////////////////////////////////////////
	//½«×Ö·û´®¸ñÊ½»¯³É16½øÖÆÏÔÊ¾ÓÃ×Ö·û´®
	//Èç"123"-> "31 32 33 "
	//@input:ÊäÈë×Ö·û´®
	//@length:ÊäÈë×Ö·û´®³¤¶È
	//@output:Êä³ö×Ö·û´®
	//@bytes_per_line:Ã¿ĞĞÊä³öµÄ×Ö·ûÊı£¬0´ú±í²»»»ĞĞ
	void xStringUtil::formatHexString(const char* input, const size_t& length, string& output, const size_t& bytes_per_line)
	{
		stringstream cache;
		unsigned char high(0), low(0);
		bool needNewLine = (0 != bytes_per_line);
		size_t count(0);
		for (size_t offset = 0; offset < length; offset++)
		{
			high = ((unsigned char)input[offset]) >> 4;					
			low = ((unsigned char)input[offset])& 0x0F;
			if (high > 9)
			{
				high += 0x37;
			}
			else{
				high += 0x30;
			}
			if (low > 9)
			{
				low += 0x37;
			}
			else{
				low += 0x30;
			}
			cache << high << low << " ";
			count++;
			if (needNewLine)
			{
				if (count == bytes_per_line)
				{
					cache << std::endl;
					count = 0;
				}
			}
		}
		if (needNewLine)
		{
			//Èç¹û²»ÊÇ¸ÕºÃnĞĞ£¬ÔòĞèÒª²¹»Ø³µ
			if (0 != (length % bytes_per_line))
			{
				cache << std::endl;
			}
		}
		output = cache.str();
	}
    int32_t xStringUtil::xstrncpy(char* dest, const char* src, int32_t n) {
        if (NULL == dest || NULL == src) {
            return -1;
        }

        int32_t ncpy = 0;

        while (*src && ncpy < n) {
            *dest++ = *src++;
            ++ncpy;
        }
        return ncpy;
    }

    std::string xStringUtil::rand_string() {
        struct timeval tv;
		xTimeUtil::gettimeofday(&tv, NULL);
        uint32_t seed = tv.tv_usec;

        std::stringstream ss;
#ifdef _WIN32
        srand( seed );
        ss << rand();
#else
        ss << rand_r(&seed);
#endif
        std::string str;
        ss >> str;
        return str;
    }

	xEmutex xStringUtil::stMutex;
}

xthreadPool.cpp/0           0     0     644     2551      `
#include "xthreadPool.h"
using namespace SEABASE;
bool xsimpleThreadPool::shutdown=false;
xMutex xsimpleThreadPool::m_threadLock;
xCondition xsimpleThreadPool::m_threadCond;
std::deque<xtaskbase*> xsimpleThreadPool::m_taskList;
#ifdef WIN32
unsigned int __stdcall xsimpleThreadPool::threadproxy(void* arg)
#else
void*  __stdcall xsimpleThreadPool::threadproxy(void* arg)
#endif
{
	pthread_t tid = pthread_self();
	xThread* pthread=(xThread*)arg;
	while(1)
	{
		xAutoLock L(m_threadLock);
		while(m_taskList.size()==0&&!shutdown)
		{
			m_threadCond.wait(m_threadLock);
		}
		if(shutdown)
		{
			pthread->destory();
			break;
		}
		xtaskbase* task=m_taskList.front();
		m_taskList.pop_front();
		task->run();
	}
	return 0;
}


void xthreadPool::initPool(size_t LowThreadNumber)
{
	if (UNINITIALIZED == m_state) {
		m_state = INITIALIZED;}
	m_threadNum=LowThreadNumber;
}
void xthreadPool::startPool(bool defaultpools )
{
	m_tasklist.setActive();// è®¾ç½®ä»»åŠ¡é˜Ÿåˆ—ä¸ºå¼€å¯çŠ¶æ€ï¼Œå¦åˆ™æ·»åŠ å’Œè¯»å–éƒ½ä¼šå¤±è´¥
	//size_t threadnum = m_threadNum?m_threadNum:4
	for(size_t i=0;i<m_threadNum;i++)
	{
		//xAutoLock L(m_lockForThread);
		threadobj *thread=new threadobj;
		//m_ThreadList.push_back(&thread);
		thread->beginthreadobj(this);
		m_ThreadList.push_back(thread);
	}

}
bool xthreadPool::pushObj(xtaskbase*node,const struct timespec & Timeout)
{
	//if(m_boStartPool && isBusy())/
	//è¿™é‡Œæœ‰ä¸ªè®²ç©¶ï¼Œä¸ç›´æ¥æ’å…¥xtaskbaseçš„å­ç±»å¯¹è±¡ï¼Œå› ä¸ºå¦‚æœå­˜å¯¹è±¡ï¼Œåœ¨æ’å…¥çš„æ—¶å€™ï¼Œä¼šè¢«å¼ºåˆ¶è½¬æ¢æˆåŸºç±»ï¼Œä¸§å¤±å­ç±»çš„éƒ¨åˆ†
	//å¦‚æœå­˜å­ç±»æŒ‡é’ˆï¼Œåœ¨waitForTask æ¥å£æ— æ³•å°†æŒ‡é’ˆä½œä¸ºä¼ å‡ºå‚æ•°ï¼Œè¿™æ ·å–ä¸åˆ°è¯¥æŒ‡é’ˆçš„åœ°å€ã€‚
	//ç”¨pair<xtaskbase*ï¼Œbool> ä½œä¸ºå€¼ç±»å‹ï¼Œå­˜å…¥ï¼Œè¿™æ ·å–å‡ºçš„æ—¶å€™ï¼Œå¯ä»¥å°†å®ƒçš„å¼•ç”¨å–å‡ºï¼Œè¿™æ ·ï¼Œå°è£…äº†å¤šæ€é—®é¢˜ï¼Œ
	//åŒæ—¶boolå‹å˜é‡ä¹Ÿå¯ç”¨æ¥ä»¥åæ‹“å±•ã€‚
	m_tasklist.pushTask(pair<xtaskbase*, bool>(node,false));
	return true;
}
void xthreadPool::stopPool(bool defaultpools/*=true*/){
	xAutoLock lock(m_lockForThread);
	m_tasklist.setDeadstatus();
	std::list<threadobj*>::iterator ite = m_ThreadList.begin();
	while(ite!=m_ThreadList.end())
	{
		(*ite)->endthreadobj();
		(*ite)->destory();
		threadobj* pobj=*ite;
		if(pobj)
			delete pobj;
		ite++;
	}
	m_tasklist.clearAllTask();
}
void xthreadPool::joinAllThread()
{
	std::list<threadobj*>::iterator ite = m_ThreadList.begin();
	while(ite!=m_ThreadList.end())
	{
		(*ite)->join();
		ite++;
	}

}
xEtcpserver.cpp/0           0     0     644     1173      `
#include "xEtcpserver.h"
using namespace SEABASE;

int xEtcpListen::startlisten(const char*ip,int port)
{
	InitSocket();
	m_listenFd = CreateSocket(SOCK_STREAM);
	bool bReuseaddr=true;
	setsockopt(m_listenFd,SOL_SOCKET,SO_REUSEADDR,(const char*)&bReuseaddr,sizeof(bool));
	if(m_listenFd==INVALID_SOCKET)
		return -1;
	struct sockaddr_in addrsvr;
	addrsvr.sin_family = AF_INET;
	addrsvr.sin_port = htons(port);
	addrsvr.sin_addr.s_addr = inet_addr(ip);
	BindSocket(m_listenFd,(SOCKADDR*)&addrsvr,sizeof(addrsvr));
	if(ListenSocket(m_listenFd,10)==INVALID_SOCKET)
		return -1;
	return m_listenFd;
}
xtcpserver::xtcpserver():m_tcpreactor(NULL)
{

}
xtcpserver::~xtcpserver()
{

}
int xEtcpListen::stoplisten()
{
	return CloseSocket(m_listenFd);
}
int xEtcpListen::getSockfd()
{
	return m_listenFd;
}

int xtcpserver::startTcpSvr(const char*ip,int port)
{

	int listenfd = m_tcplistener.startlisten(ip,port);
	//m_tcpreactor = reactor;
	//m_tcpreactor->Register
	return listenfd;
}
int xtcpserver::stopTcpSvr()
{
	m_tcplistener.stoplisten();
	return 0;
}
int xtcpserver::getListenfd()
{
	 return m_tcplistener.getSockfd();
}
xNetdata.cpp/   0           0     0     644     1826      `
#include "xNetdata.h"
using namespace SEABASE;

void Eventcallback::InitEvent(xEvent_t& e, SOCKET sock, void *arg,pcallbackptr func)
{
	e.m_Eventfd=sock;
	e.m_eventmask=xReadEvent|xErrorEvent;
	e.m_readptr = func;
	e.m_readarg = arg;
	e.m_writearg=arg;
	//e.m_writeptr=
	e.m_errorptr=ErrCallback;
	e.m_errorarg=arg;
}
void Eventcallback::AcceptCallback(int sockfd,xEventDemultiplexer*Demultiplexer,void *arg)
{
	struct sockaddr_in clientaddr;
	socklen_t socklen=sizeof(struct sockaddr_in);
	int acceptfd=AccpetSocket(sockfd,(SOCKADDR*)&clientaddr,&socklen);
	if((SOCKET)acceptfd==INVALID_SOCKET)
		return ;
	xReceivebackbase * pclientEvent=NULL;
	xItcpserver*pserver = (xItcpserver*)arg;
	if(!pserver)	return ;
	pserver->Onaccept(acceptfd,NULL,0,(xReceivebackbase**)&pclientEvent);
	//m_Eventfd=acceptfd;
	if(pclientEvent)  //ÕâÀï×¢²áacceptµÄfd,
	{
		xEvent_t e;
		InitEvent(e,acceptfd,pclientEvent,DataCallback);
		Demultiplexer->RequestEvent(e);
	}
	else if(pclientEvent==NULL)
	{
		//pserver->m_readptr=DataCallback;
		xEvent_t e;
		InitEvent(e,acceptfd,arg,DataCallback);
		Demultiplexer->RequestEvent(e);
	}
	
	return ;
}
void Eventcallback::DataCallback(int sockfd,xEventDemultiplexer*Demultiplexer,void *arg)
{
	char buf[MAXREADSIZE]={0};
	int len=MAXREADSIZE;
	xReceivebackbase*pserver = (xReceivebackbase*)arg;
	if(!pserver)	return ;
	int iret = ReadSocket(sockfd,buf,len);
	len=sizeof(buf);
	if(iret==0)
	{
		CloseSocket(sockfd);
		if(Demultiplexer)
			Demultiplexer->UnrequestEvent(sockfd);
		//ShutDownSocket(listentfd,0);
		pserver->Onclose(sockfd);
		//CloseSocket(listentfd);
	}
	else if(iret>=0)
		pserver->Ondata(sockfd,buf,iret);
	else
		return ;
}
void Eventcallback::ErrCallback(int sockfd,xEventDemultiplexer*Demultiplexer,void *arg)
{

}xbaseLog.cpp/   0           0     0     644     9739      `
///////////////////////////////////////////////////////////////////////
/* ÎÄ¼şÃû£º xbaseLog.cpp
 ÎÄ¼ş×÷ÓÃ£º		
    ÊµÏÖÈÕÖ¾log    
//-------------------------------------------------------------------
 ĞŞ¸ÄÀúÊ·¼ÇÂ¼£º
    ĞŞ¸ÄÊ±¼ä      2020-11-9
    ĞŞ¸ÄÈË        xjshi
    ĞŞ¸ÄÄÚÈİ¸ÅÒª  
*/
///////////////////////////////////////////////////////////////////////

//#include "stdafx.h"

#include <sstream>
#include "xbaseLog.h"
const char *LIB_INFO = "libseabase.so versions: 1.0.2#20210323 ";


#define SLASH "/"

namespace SEABASE{


	xbaseLog::xbaseLog()
	{
		m_logDate = "";
		m_logPath = "../log/";
		m_logName = "log";
		m_logFile = NULL;
        m_loglevel = LOG_DEBUG;
        m_loglevelstr = "DEBUG";
	}
	
	xbaseLog::xbaseLog(string logname)
	{
		m_logDate = "";
		m_logPath = "../log/";
		m_logName = logname;
		m_logFile = NULL;	
        loglevel=LOG_DEBUG;
	}

	xbaseLog::~xbaseLog()
	{
	   closelogFile();
	}

	void xbaseLog::setLogName(string strLogName)
	{
		m_logName = strLogName;
	}
     void xbaseLog::setLoglevel(int level)
     {
         switch(level)
         {
         case LOG_ERROR:
             {
                 m_loglevel = LOG_ERROR;
                 m_loglevelstr = "ERROR";
             }
             break;
         case LOG_INFO:
             {
                 m_loglevel = LOG_INFO;
                 m_loglevelstr = "INFO";
             }
             break;
         case LOG_DEBUG:
             {
                 m_loglevel = LOG_DEBUG;
                 m_loglevelstr = "DEBUG";
             }
             break;
         }
     }
	void xbaseLog::setLogModule(string strLogName)
	{
		m_logName = strLogName;
	}

	void xbaseLog::setLogPath(string strLogPath)
	{
		m_logPath = strLogPath;

		if (xEFile::Exists(m_logPath))
		{
			xEFile::MakePath(m_logPath);
		}
	}
		////////////////////////////////////////////////////////////////
	// º¯ÊıÃû£º  openLogFile()
	// ËµÃ÷£º   ´ò¿ªÈÕÖ¾¼ÇÂ¼ÎÄ¼ş
	// ÊäÈë²ÎÊı£ºÎŞ
	// ·µ»ØÖµ£º  ÎŞ
	//-------------------------------------------------------------
	bool xbaseLog::openLogFile()
	{
		if(NULL != m_logFile)
			fclose(m_logFile);

		string strDate = xTimeUtil::get_date();

		if (!xEFile::Exists(m_logPath))
		{
			xEFile::MakePath(m_logPath);
		}

		string logDate = xTimeUtil::get_date();
		m_logDate = logDate;

		string dateDir = m_logPath + logDate + SLASH;
		if(!xEFile::Exists(dateDir))
		{
			xEFile::MakePath(dateDir);
		}

		if(!xEFile::Exists(m_logPath +  strDate + SLASH))
		{
			xEFile::MakePath(m_logPath + strDate + SLASH);
		}
		string filename = m_logPath + strDate + SLASH + m_logName + ".log";
		m_logFile = fopen(filename.c_str(), "at+");

		return (NULL != m_logFile);
	}


	////////////////////////////////////////////////////////////////
	// º¯ÊıÃû£º  closelogFile()
	// ËµÃ÷£º   ¹Ø±ÕÖ¾¼ÇÂ¼ÎÄ¼ş
	// ÊäÈë²ÎÊı£ºÎŞ
	// ·µ»ØÖµ£º  ÎŞ
	////////////////////////////////////////////////////////////////
	void xbaseLog::closelogFile()
	{
		if(NULL != m_logFile)
		{
			fprintf(m_logFile, "log file close\n\n");
			fflush(m_logFile);
			fclose(m_logFile);
		}

		m_logFile = NULL;
	}

	void xbaseLog::closeLogFile()
	{
		if(NULL != m_logFile)
		{
			fprintf(m_logFile, "log file close\n\n");
			fflush(m_logFile);
			fclose(m_logFile);
		}

		m_logFile = NULL;
	}

	void xbaseLog::close()
	{
		
	}
	////////////////////////////////////////////////////////////////
	// º¯ÊıÃû£º  printLog()
	// ËµÃ÷£º   ´òÓ¡ÈÕÖ¾
	// ÊäÈë²ÎÊı£ºformat - ÈÕÖ¾´®
	// ·µ»ØÖµ£º  ÎŞ
	//-------------------------------------------------------------
	////////////////////////////////////////////////////////////////
	void xbaseLog::printLog(const char* format, ...)
	{
		xGuard<xEmutex> lock(&log_mutex);


		enum{
			max_buf_length = 1000,
		};

		if(NULL == m_logFile)
		{
			if(!openLogFile())
				return;
		}


		try
		{
			string logDate = xTimeUtil::get_date();
			if(m_logDate.compare(logDate) != 0)
			{
				openLogFile();
				//m_currLogCount = 1;
			}

			if(NULL == m_logFile)
				return;

			char buffer[max_buf_length + 1] = {0};
			memset(buffer, 0x00, sizeof(buffer));
			va_list ap;
			va_start(ap, format);
			vsnprintf(buffer, max_buf_length, format, ap);
			va_end(ap);

		//	string content(buffer);
			fprintf(m_logFile, "%s  %s", xTimeUtil::getCurrentTimeStamp().c_str(), buffer);
			fflush(m_logFile);
		}
		catch (...){}
	}
    void xbaseLog::innerprintlog(const char* filename,int line,const char*strdsc,const char *format ,va_list ap)
    {
        enum{
            max_buf_length = 8192,
        };

        if(NULL == m_logFile)
        {
            if(!openLogFile())
                return;
        }

        if(m_logDate != xTimeUtil::get_date())
        {
            if(!openLogFile())
                return;
        }

        try
        {
            char buffer[max_buf_length + 1] = {0};
          //  va_list ap;
         //   va_start(ap, format);
            vsnprintf(buffer, max_buf_length, format, ap);
         //   va_end(ap);

            //	string content(buffer);
            fprintf(m_logFile, "[%s:%05d][%s][%s]%s", filename,line,strdsc,xTimeUtil::getCurrentTimeStamp().c_str(), buffer);
            fflush(m_logFile);
        }
        catch (...){}
    }
    void xbaseLog::printerror(const char* filename,int line,const char*format,...)
    {
		xGuard<xEmutex> lock(&log_mutex);
        if(m_loglevel < LOG_ERROR)
            return;
        va_list ap;
        va_start(ap,format);
        innerprintlog(filename,line,logdsc[LOG_ERROR].c_str(),format,ap);
        va_end(ap);
    }
    void xbaseLog::printinfo(const char* filename,int line,const char*format,...)
    {
		xGuard<xEmutex> lock(&log_mutex);
        if(m_loglevel < LOG_INFO)
            return;
        va_list ap;
        va_start(ap,format);
        innerprintlog(filename,line,logdsc[LOG_INFO].c_str(),format,ap);
        va_end(ap);
        //innerprintlog(filename,line,logdsc[LOG_INFO].c_str(),format);
    }
    void xbaseLog::printdebug(const char* filename,int line,const char*format,...)
    {
		xGuard<xEmutex> lock(&log_mutex);

        if(m_loglevel < LOG_DEBUG)
            return;
       // innerprintlog(filename,line,logdsc[LOG_DEBUG].c_str(),format);
        va_list ap;
        va_start(ap,format);
        innerprintlog(filename,line,logdsc[LOG_DEBUG].c_str(),format,ap);
        va_end(ap);
    }
	void xbaseLog::info(const char* format, ...)
	{
		xGuard<xEmutex> lock(&log_mutex);

        enum{
			max_buf_length = 8192,
		};

		if(NULL == m_logFile)
		{
			if(!openLogFile())
				return;
		}

		if(m_logDate != xTimeUtil::get_date())
		{
		    if(!openLogFile())
				return;
		}

		try
		{
			char buffer[max_buf_length + 1] = {0};
			va_list ap;
			va_start(ap, format);
			vsnprintf(buffer, max_buf_length, format, ap);
			va_end(ap);

		//	string content(buffer);
			fprintf(m_logFile, "%s  %s", xTimeUtil::getCurrentTimeStamp().c_str(), buffer);
			fflush(m_logFile);
		}
		catch (...){}
	}
	void xbaseLog::info(unsigned int index, const char* format, ...)
	{
		xGuard<xEmutex> lock(&log_mutex);


		enum{
			max_buf_length = 8192,
		};

		if(NULL == m_logFile)
		{
			if(!openLogFile())
				return;
		}

		if(m_logDate != xTimeUtil::get_date())
		{
		    if(!openLogFile())
				return;
		}

		try
		{
		    char buffer[max_buf_length + 1] = {0};
			va_list ap;
			va_start(ap, format);
			vsnprintf(buffer, max_buf_length, format, ap);
			va_end(ap);

		//	string content(buffer);
			string strInfo = xTimeUtil::getCurrentTimeStamp() + " " + buffer;
		    fprintf(m_logFile, "%s", strInfo.c_str());
			fflush(m_logFile);
		}
		catch (...){}
	}
	
	void xbaseLog::error(const char* format, ...)
	{
		enum{
			max_buf_length = 8192,
		};

		if(NULL == m_logFile)
		{
			if(!openLogFile())
				return;
		}

		if(m_logDate != xTimeUtil::get_date())
		{
		    if(!openLogFile())
				return;
		}

		try
		{
			char buffer[max_buf_length + 1] = {0};
			va_list ap;
			va_start(ap, format);
			vsnprintf(buffer, max_buf_length, format, ap);
			va_end(ap);

		//	string content(buffer);
			fprintf(m_logFile, "%s  %s", xTimeUtil::getCurrentTimeStamp().c_str(), buffer);
			fflush(m_logFile);
		}
		catch (...){}
	}

	void xbaseLog::error(unsigned int index, const char* format, ...)
	{
		enum{
			max_buf_length = 8192,
		};

		if(NULL == m_logFile)
		{
			if(!openLogFile())
				return;
		}

		if(m_logDate != xTimeUtil::get_date())
		{
		    if(!openLogFile())
				return;
		}

		try
		{
			char buffer[max_buf_length + 1] = {0};
			va_list ap;
			va_start(ap, format);
			vsnprintf(buffer, max_buf_length, format, ap);
			va_end(ap);

	//		string content(buffer);
			fprintf(m_logFile, "%s  %s", xTimeUtil::getCurrentTimeStamp().c_str(), buffer);
			fflush(m_logFile);
		}
		catch (...){}
	
	}

	void xbaseLog::warn(const char* format, ...)
	{
	    xGuard<xEmutex> lock(&log_mutex);

		enum{
			max_buf_length = 8192,
		};

		if(NULL == m_logFile)
		{
			if(!openLogFile())
				return;
		}

		if(m_logDate != xTimeUtil::get_date())
		{
		    if(!openLogFile())
				return;
		}

		try
		{
			char buffer[max_buf_length + 1] = {0};
			va_list ap;
			va_start(ap, format);
			vsnprintf(buffer, max_buf_length, format, ap);
			va_end(ap);

		//	string content(buffer);
			string strInfo = xTimeUtil::getCurrentTimeStamp() + " " + buffer;

		//	m_msgQueue.TryPut(strInfo);

			fprintf(m_logFile, "%s  %s", xTimeUtil::get_date().c_str(), buffer);
			fflush(m_logFile);
		}
		catch (...){}
	}

	void xbaseLog::writeLog(string strInfo)
	{
		enum{
			max_buf_length = 8192,
		};

		if(NULL == m_logFile)
		{
			if(!openLogFile())
				return;
		}

		if(m_logDate != xTimeUtil::get_date())
		{
		    if(!openLogFile())
				return;
		}

		try
		{
			fprintf(m_logFile, "%s", strInfo.c_str());
			fflush(m_logFile);
		}
		catch (...){}
	}
}

/47             0           0     0     644     2503      `
//xjshi 2019/3/13
//ÖØ¹¹hpp
#include "xEventDemultiplexer.h"
using namespace SEABASE;
#ifndef WIN32
xEpollDemultiplexer::xEpollDemultiplexer()
{
	m_epoll_fd=::epoll_create(FD_SETSIZE);
	//assert(m_epoll_fd!=-1);
	m_fd_num=0;
}
xEpollDemultiplexer::~xEpollDemultiplexer()
{
	::close(m_epoll_fd);
}

//³¬Ê±Îª0,Ôò²»×èÈû£¬Á¢¼´·µ»Ø£¬timeoutµ¥Î» ms.
int xEpollDemultiplexer::WaitEvents( int timeout/* =0 */,xtime_heap* event_timer/* =NULL */ )
{
	std::vector<epoll_event> ep_events(m_fd_num);
	int num = epoll_wait(m_epoll_fd,&ep_events[0],ep_events.size(),timeout);
	if(num > 0)
	{
		for(int idx = 0;idx<num;++idx)
		{
			int handle = ep_events[idx].data.fd;

			if(ep_events[idx].events & EPOLLERR || (ep_events[idx].events & EPOLLHUP))
			{
				if(m_handlers[handle].m_errorptr)
				{
					m_handlers[handle].m_errorptr(handle,this,(void*)m_handlers[handle].m_errorarg);
				}
			}
			else
			{
				if(ep_events[idx].events & EPOLLIN)
				{
					//(*handlers)[handle]->HandleRead(handle,this);
					if(m_handlers[handle].m_readptr)
					{
						m_handlers[handle].m_readptr(handle,this,(void*)m_handlers[handle].m_readarg);
					}
				}
				if(ep_events[idx].events & EPOLLOUT)
				{
					if(m_handlers[handle].m_writeptr)
					{
						m_handlers[handle].m_writeptr(handle,this,(void*)m_handlers[handle].m_writearg);
					}
				}
			}
		}

	}
	if(event_timer !=NULL)
	{
		event_timer->tick();
	}
	return num;
}

int xEpollDemultiplexer::RequestEvent(xEvent_t&e)
{
	epoll_event ep_event;
	ep_event.data.fd = e.m_Eventfd;
	ep_event.events = 0;
	if(e.m_eventmask &xReadEvent ) //	 ¶ÁÊÂ¼ş
	{
		ep_event.events |= EPOLLIN;
	}
	if(e.m_eventmask&xWriteEvent) // Ğ´ÊÂ¼ş
	{
		ep_event.events |=EPOLLOUT;
	}
	if(epoll_ctl(m_epoll_fd,EPOLL_CTL_MOD,e.m_Eventfd,&ep_event)!=0)
	{
		if(errno ==ENOENT)
		{
			if(epoll_ctl(m_epoll_fd,EPOLL_CTL_ADD,e.m_Eventfd,&ep_event)!=0)
			{
				return -errno;
			}
			++m_fd_num;
		}
	}
	int handle = e.m_Eventfd;
	std::map<handle_t,xEvent_t>::iterator it = m_handlers.find(handle);
	if(it==m_handlers.end())
	{
		m_handlers[handle]=e;
	}
	return 0;
}

int xEpollDemultiplexer::UnrequestEvent(handle_t handle)
{
	epoll_event ep_event;
	if(epoll_ctl(m_epoll_fd,EPOLL_CTL_DEL,handle,&ep_event)!=0)
	{
		return -errno;
	}
	--m_fd_num;
	std::map<handle_t,xEvent_t>::iterator it = m_handlers.find(handle);
	if(it==m_handlers.end())
	{
		m_handlers.erase(handle);
	}
}

#endif

xsema.cpp/      0           0     0     644     2294      `
#include "xsema.h"
using namespace SEABASE;

#ifndef _WIN32
static int32_t get_abs_timespec(struct timespec* ts, int32_t millisecond) {
	struct timeval tv;
	int32_t ret;

	if (NULL == ts) {
		return EINVAL;
	}

	ret = gettimeofday(&tv, NULL);
	if (0 != ret) {
		return ret;
	}

	ts->tv_sec = tv.tv_sec;
	ts->tv_nsec = tv.tv_usec * 1000UL;

	ts->tv_sec += millisecond / 1000UL;
	ts->tv_nsec += millisecond % 1000UL * 1000000UL;

	ts->tv_sec += ts->tv_nsec/(1000UL * 1000UL *1000UL);
	ts->tv_nsec %= (1000UL * 1000UL *1000UL);

	return 0;
}
#endif
xSemaphore::xSemaphore(int init)
{
	if(init<0)
	{
		init=0;
	}
#ifdef _WIN32
	_sem = CreateSemaphore(NULL,init,LONG_MAX,NULL);
#else
	sem_init(&_sem,0,init);
#endif
}

xSemaphore::~xSemaphore()
{
#ifdef _WIN32
	if(NULL!=_sem)
	{
		bool ret = CloseHandle(_sem);
		if(0!=ret)
		{
			_sem=NULL;
		}
	}
#else
	sem_destroy(&_sem);
#endif
}

int32_t xSemaphore::wait(uint32_t millisecond /* = INFINITE */)
{
#ifdef _WIN32
	if(NULL==_sem){return SEA_NULL_POINTER;}
	DWORD ret = WaitForSingleObject(_sem,millisecond);
	if(WAIT_OBJECT_0 == ret || WAIT_ABANDONED == ret){return 0;}
	else if (WAIT_TIMEOUT == ret)
	{
		return SEA_TIMEOUT;
	}
	else return SEA_SYSERROR;
#else
	int32_t ret = 0;
	if(millisecond == INFINITE)
	{
		while((ret=sem_wait(&_sem))==-1&&EINTR==errno);
	}
	else{
		struct timespec ts = {0,0};
		get_abs_timespec(&ts,millisecond);
		while((ret=sem_timedwait(&_sem,&ts))==-1&&EINTR==errno);
	}
	if(0!=ret)
	{
		if(errno == ETIMEDOUT)
			return SEA_TIMEOUT;
		else
			return SEA_SYSERROR;
	}

	return SEA_SUCCESS;
#endif
}
bool xSemaphore::try_wait(){
#ifdef _WIN32
	if (NULL == _sem) {
		return false;
	}

	DWORD ret = WaitForSingleObject(_sem, 0);
	if (WAIT_OBJECT_0 == ret || WAIT_ABANDONED == ret) {
		return true;
	}

	return false;
#else
	int32_t ret=0;
	while((ret=sem_trywait(&_sem))==-1 && EINTR==errno);
	return (0==ret);
#endif

}

int32_t xSemaphore::signal()
{
#ifdef _WIN32
	bool ret = FALSE;
	if(NULL != _sem)
	{
		ret = ReleaseSemaphore(_sem,1,NULL);
	}
	return (0!=ret?0:SEA_SYSERROR);
#else
	int32_t ret=0;
	while((ret=sem_post(&_sem))==-1&&EINTR==errno);
	return (0==ret?0:SEA_SYSERROR);
#endif
}xthreadbase.cpp/0           0     0     644     3000      `
#include "xthreadbase.h"
using namespace SEABASE;

#ifdef WIN32
	 unsigned int __stdcall Threadbase::thread_proxy(void* arg)
#else
	 void*  __stdcall Threadbase::thread_proxy(void* arg)
#endif
{
	Threadbase* pbase=static_cast<Threadbase*> (arg);
// 	pbase->m_LockState.lock();
// 	pbase->m_ConditionState.signal();
// 	pbase->m_LockState.unlock();
	pbase->m_sema.signal();
	pbase->run();
	return 0;
}

Threadbase::Threadbase(bool bDetach):m_state(INIT),bExit_(false)
{
	thr_id=0;
}
Threadbase::~Threadbase()
{
	//join();
	m_sema.signal();
	destory();
	m_state=STOP;
	//printf("~Threadbase\n");
}

int Threadbase::start()
{
	if(m_state!=INIT)
		return -1;
	//xAutoLock L(m_LockState);
#ifdef WIN32
	unsigned int nval=_beginthreadex(0,0,thread_proxy,this,0,&thr_id);
	thr_id=nval;
#else
	pthread_attr_t attr;
	int arg=0;
	pthread_create(&thr_id,NULL,thread_proxy,this);
#endif
	m_sema.wait();
	
	m_state=START;
	return 0;
}
int Threadbase::join()
{
	if(m_state!=START&&m_state!=STOP)
		return -1;
#ifdef WIN32
	//WAIT_OBJECT è¡¨ç¤ºæ‰§è¡Œç»“æŸ
	if(thr_id!=0)
	{
		DWORD dw= WaitForSingleObject(reinterpret_cast<HANDLE>(thr_id),INFINITE);
		if(WAIT_OBJECT_0==dw ||WAIT_ABANDONED == dw)
		{
			CloseHandle(reinterpret_cast<HANDLE>(thr_id)); //é‡Šæ”¾å¥æŸ„èµ„æºï¼Œçº¿ç¨‹å¹¶æ²¡æœ‰ç»“æŸ
			thr_id=0;
			printf("\n join thread %d finish\n",thr_id);
		}
	}
#else
	pthread_join(thr_id,NULL);
#endif
	m_state = JOINED;
	return 0;
}
void Threadbase::destory()
{
	if(m_state!=STOP && m_state>=START)
	{
		bExit_ = true;
		m_state = STOP;
#ifdef WIN32
		CloseHandle(reinterpret_cast<HANDLE>(thr_id));
#else
		int thread_return;
		//pthread_exit((void*)&thread_return); //å¦‚æœå¼ºè¡Œé€€å‡ºï¼Œçº¿ç¨‹é‡Œé¢çš„ä¸€äº›å¯¹è±¡èµ„æºä¸ä¼šè°ƒç”¨ææ„ï¼Œå¯èƒ½ä¼šå†…å­˜æ³„éœ²
#endif
		thr_id=NULL;
	}

}
//////////////////////////////////////////////////////////////////////////
//xThread å®ç°


int xThread::start(pfunc func,void *arg)
{
	if(m_state!=INIT)
		return -1;
#ifdef WIN32
	unsigned int nval=_beginthreadex(0,0,func,arg,0,&thr_id);
	thr_id=nval;
#else
	pthread_create(&thr_id,NULL,func,arg);
#endif
	m_state=START;
	return 0;
}
int xThread::join()
{
	if(m_state!=START&&m_state!=STOP)
		return -1;
#ifdef WIN32
	//WAIT_OBJECT è¡¨ç¤ºæ‰§è¡Œç»“æŸ
	if(thr_id!=0)
	{
		DWORD dw= WaitForSingleObject(reinterpret_cast<HANDLE>(thr_id),INFINITE);
		if(WAIT_OBJECT_0==dw ||WAIT_ABANDONED == dw)
		{
			CloseHandle(reinterpret_cast<HANDLE>(thr_id)); //é‡Šæ”¾å¥æŸ„èµ„æºï¼Œçº¿ç¨‹å¹¶æ²¡æœ‰ç»“æŸ
			thr_id=0;
			printf("\n join thread %d finish\n",thr_id);
		}
	}
#else
	pthread_join(thr_id,NULL);
#endif
	m_state = JOINED;
	return 0;
}
void xThread::destory()
{
	if(m_state!=STOP && m_state>=START)
	{
		bExit_ = true;
		m_state = STOP;
#ifdef WIN32
		CloseHandle(reinterpret_cast<HANDLE>(thr_id));
#else
		int thread_return;
		//pthread_exit((void*)&thread_return);
#endif
	}
}xTimeuil.cpp/   0           0     0     644     9836      `
#include "xTimeuil.h"
#include <iostream>
#include "xStringuil.h"
namespace SEABASE
{

    static struct tm* localtime_r(const time_t* timep, struct tm* result = NULL) {
#ifdef WIN32
        (void)result;
        return localtime(timep);
#else
        return ::localtime_r(timep, result);
#endif
    }

#ifdef _WIN32
    //gettimeofday ÒıÓÃ×Ôhttp://suacommunity.com/dictionary/gettimeofday-entry.php
    FILETIME xTimeUtil::_ft = {0};
	LARGE_INTEGER xTimeUtil::_pform = {0};
#endif
	  
    int32_t xTimeUtil::gettimeofday(struct ::timeval *tv, struct timezone *tz)
    {
#ifndef _WIN32
        return ::gettimeofday(tv,tz);
#else
        FILETIME ft;

        unsigned __int64 tmpres = 0;
        unsigned __int64 tmpres2 = 0;
        static int tzflag = 0;
        LARGE_INTEGER pform={0};
        QueryPerformanceCounter(&pform);

        if (NULL != tv)
        {
            GetSystemTimeAsFileTime(&ft);
            if(ft.dwLowDateTime == _ft.dwLowDateTime && ft.dwHighDateTime == _ft.dwHighDateTime)
            {
                //Ê±¼äÏàµÈÊ±£¬¼ÆËãÊ±¼äÆ«ÒÆ
                LARGE_INTEGER pfreq = {0};
                QueryPerformanceFrequency(&pfreq);
                tmpres2 = ((pform.QuadPart - _pform.QuadPart) * 1000000UL)/pfreq.QuadPart;
            }
            else
            {
                //Ê±¼ä²»µÈÊ±£¬¸üĞÂ±ê×¼Ê±¼ä
                xTimeUtil::_ft = ft;
                QueryPerformanceCounter(&_pform);
            }

            tmpres |= ft.dwHighDateTime;
            tmpres <<= 32;
            tmpres |= ft.dwLowDateTime;

            tmpres /= 10;
            tmpres -= DELTA_EPOCH_IN_MICROSECS;
			tmpres += tmpres2;	//Ôö¼ÓĞŞÕıÆ«ÒÆ


            tv->tv_sec = (long)(tmpres / 1000000UL);
            tv->tv_usec = (long)(tmpres % 1000000UL);
        }

        if (NULL != tz)
        {
            if (!tzflag)
            {
                _tzset();
                tzflag++;
            }

            tz->tz_minuteswest = _timezone / 60;
            tz->tz_dsttime = _daylight;
        }

        return 0;
#endif
    }

    uint64_t xTimeUtil::get_timestamp_s() {
        struct ::timeval tv = {0, 0};
		gettimeofday(&tv, NULL);
        return tv.tv_sec;
    }

    uint64_t xTimeUtil::get_timestamp_ms() {
        struct ::timeval tv = {0, 0};
        gettimeofday(&tv, NULL);
        return (uint64_t)tv.tv_sec * 1000 + tv.tv_usec / 1000;
    }

    uint64_t xTimeUtil::get_timestamp_us() {
        struct ::timeval tv = {0, 0};
        gettimeofday(&tv, NULL);
        return (uint64_t)tv.tv_sec * 1000000 + tv.tv_usec;
    }

    void xTimeUtil::safe_sleep_s(uint32_t second) {
#ifdef _WIN32
        return xTimeUtil::safe_sleep_ms(second * 1000);
#else
        struct timespec interval, remainder;
        int32_t ret;

        interval.tv_sec = second;
        interval.tv_nsec = 0;

        ret = nanosleep(&interval, &remainder);
        if (-1 == ret) {
            while (EINTR == errno && -1 == ret) {
                ret = nanosleep(&remainder, &remainder);
            }
        }
#endif
    }

    void xTimeUtil::safe_sleep_ms(uint32_t millisecond) {
#ifdef _WIN32
        ::Sleep(millisecond);
#else
        struct timespec interval, remainder;
        int32_t ret;

        interval.tv_sec = millisecond / 1000U;
        interval.tv_nsec = (uint64_t)millisecond % 1000UL * 1000UL * 1000UL;

        ret = nanosleep(&interval, &remainder);
        if (-1 == ret) {
            while (EINTR == errno && -1 == ret) {
                ret = nanosleep(&remainder, &remainder);
            }
        }
#endif
    }

    std::string xTimeUtil::format_datetime_str(uint64_t millisecond) {
        time_t time = (time_t)(millisecond / 1000);
        struct tm t;
        struct tm *pt = NULL;
        char buffer[24] = {0};

        pt = SEABASE::localtime_r(&time, &t);
        if(NULL != pt)
        {
            t = *pt;
            snprintf(buffer, 24, "%04d-%02d-%02d %02d:%02d:%02d.%03d",
                t.tm_year + 1900, t.tm_mon + 1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, (int32_t)(millisecond % 1000));
        }
        return std::string(buffer);
    }

#ifndef _WIN32
    int32_t xTimeUtil::get_abs_timespec(struct timespec* ts, int32_t millisecond) {
        struct timeval tv;
        int32_t ret;

        if (NULL == ts) {
            return EINVAL;
        }

        ret = gettimeofday(&tv, NULL);
        if (0 != ret) {
            return ret;
        }

        ts->tv_sec = tv.tv_sec;
        ts->tv_nsec = tv.tv_usec * 1000UL;

        ts->tv_sec += millisecond / 1000UL;
        ts->tv_nsec += millisecond % 1000UL * 1000000UL;

        ts->tv_sec += ts->tv_nsec/(1000UL * 1000UL *1000UL);
        ts->tv_nsec %= (1000UL * 1000UL *1000UL);

        return 0;
    }
#endif

    int32_t xTimeUtil::strftimeval(char* buffer, int32_t buflen, const struct timeval* tv) {
        if (NULL == buffer || NULL == tv) {
            return -1;
        }

        time_t time = tv->tv_sec;
        struct tm t;
        struct tm *pt = NULL;

        pt = SEABASE::localtime_r(&time, &t);
        if(NULL == pt)
        {
            return -1;
        }
        t = *pt;
        return snprintf(buffer, buflen, "%04d-%02d-%02d %02d:%02d:%02d.%03d",
                t.tm_year + 1900, t.tm_mon + 1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, (int32_t)tv->tv_usec / 1000);   
    }

    std::string xTimeUtil::get_date() {
        time_t t = time(NULL);
        struct tm result;
        struct tm *presult = NULL;
        char buffer[20] = {0};
        presult = SEABASE::localtime_r(&t, &result);
        if(NULL != presult)
        {
            result = *presult;
            strftime(buffer, 20, "%Y%m%d", &result);
        }

        return std::string(buffer);
    }

    std::string xTimeUtil::get_time() {
        time_t t = time(NULL);
        struct tm result;
        struct tm *presult = NULL;
        char buffer[20] = {0};
        presult = SEABASE::localtime_r(&t, &result);
        if(NULL != presult)
        {
            result = *presult;
            strftime(buffer, 20, "%H%M%S", &result);
        }

        return std::string(buffer);
    }
	//»ñÈ¡µ±Ç°Ê±¼ä´ÁµÄ×Ö·û´®ĞÎÊ½
	//¸ñÊ½£ºYYYY-MM-DD HH:MI:SS.ms
	string xTimeUtil::getCurrentTimeStamp()
	{
		struct timeval tv;
		struct timezone tz;
		gettimeofday(&tv , &tz);

		time_t now = time(0);
		struct tm *ts = localtime(&now);
		if (!ts)
			return "";
		char buf[24] = {'\0'};
		//sprintf ¿ÉÄÜ»á·¢ÉúÔ½½ç£¬²»»á×Ô¶¯Ìí¼Ó'\0',Ê¹ÓÃsnprintf
		snprintf(buf,23,"%04d-%02d-%02d %02d:%02d:%02d.%03d",
			ts->tm_year + 1900, ts->tm_mon+1,ts->tm_mday, ts->tm_hour, ts->tm_min, ts->tm_sec,tv.tv_usec);
		printf("time=%s\n",buf);
		return buf;
	}
    int32_t xTimeUtil::get_day()
    {
        time_t t = time(NULL);
        struct tm result;
        struct tm *presult = NULL;
        presult = SEABASE::localtime_r(&t, &result);
        if(NULL == presult)
        {
            return -1;
        }
        result = *presult;
        return result.tm_wday;
    }

    int32_t xTimeUtil::get_day( time_t time )
    {
        struct tm result;
        struct tm *presult = NULL;
        presult = SEABASE::localtime_r(&time, &result);
        if(NULL == presult)
        {
            return -1;
        }
        result = *presult;
        return result.tm_wday;
    }

    std::string xTimeUtil::format_time(const char * fmt)
    {
        //»ñÈ¡Ê±¼ä
        struct ::timeval tv = {0, 0};
        gettimeofday(&tv, NULL);
        
        return format_time(&tv, fmt);
    }
    
    std::string xTimeUtil::format_time(time_t time, const char * fmt)
    {
        struct ::timeval tv = {0, 0};
        tv.tv_sec = static_cast <long>(time);

        return format_time(&tv, fmt);
    }

    std::string xTimeUtil::format_time(const struct timeval* tv, const char * fmt)
    {
        struct tm result;
        struct tm  *presult = NULL;
        time_t t = tv->tv_sec;
        char buffer[50] = {0};
        char tmp[8];
        if(NULL == fmt)
        {
            //¸ñÊ½»¯µ±Ç°Ê±¼ä
            presult = SEABASE::localtime_r(&t, &result);
            if(NULL != presult)
            {
                result = *presult;
                strftime(buffer, sizeof(buffer), "%Y%m%d-%H:%M:%S", &result);
            }
        }
        else
        {
            std::string str_fmt(fmt);
            std::string str_tmp;
            if(std::string::npos != str_fmt.find("[m]"))
            {
                //Ìæ»»ºÁÃëÊ±¼ä
                snprintf(tmp,8,"%03d", (int)(tv->tv_usec / 1000) );
                str_tmp.assign(tmp);
                str_fmt = xStringUtil::replace_string(str_fmt, "[m]", str_tmp);
            }
            if(std::string::npos != str_fmt.find("[u]"))
            {
                //Ìæ»»Î¢ÃëÊ±¼ä
                snprintf(tmp,8,"%06d", (int)(tv->tv_usec) );
                str_tmp.assign(tmp);
                str_fmt = xStringUtil::replace_string(str_fmt, "[u]", str_tmp);
            }
            if(std::string::npos != str_fmt.find("[U]"))
            {
                //Ìæ»»Î¢ÃëÊ±¼ä
                snprintf(tmp,8,"%03d", (int)(tv->tv_usec % 1000) );
                str_tmp.assign(tmp);
                str_fmt = xStringUtil::replace_string(str_fmt, "[U]", str_tmp);
            }
            presult = SEABASE::localtime_r(&t, &result);
            if(NULL != presult)
            {
                result = *presult;
                strftime(buffer, sizeof(buffer), str_fmt.c_str(), &result);
            }
        }
        return std::string(buffer);
    }
}

xEmutex.cpp/    0           0     0     644     3065      `
#include "xEmutex.h"
using namespace SEABASE;
#ifndef _WIN32
static int32_t get_abs_timespec(struct timespec* ts, int32_t millisecond) {
	struct timeval tv;
	int32_t ret;

	if (NULL == ts) {
		return EINVAL;
	}

	ret = gettimeofday(&tv, NULL);
	if (0 != ret) {
		return ret;
	}

	ts->tv_sec = tv.tv_sec;
	ts->tv_nsec = tv.tv_usec * 1000UL;

	ts->tv_sec += millisecond / 1000UL;
	ts->tv_nsec += millisecond % 1000UL * 1000000UL;

	ts->tv_sec += ts->tv_nsec/(1000UL * 1000UL *1000UL);
	ts->tv_nsec %= (1000UL * 1000UL *1000UL);

	return 0;
}
#endif
xEmutex::xEmutex()
{
#ifdef _WIN32
	_mutex = CreateMutex(NULL, FALSE, NULL);
#else
	int32_t ret = 0;
	pthread_mutexattr_t attr;

	ret = pthread_mutexattr_init(&attr);
	if (0 != ret) {
		ret = pthread_mutex_init(&this->_mutex, NULL);
	} else {
		ret = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK_NP);
		ret = pthread_mutex_init(&_mutex, &attr);
		pthread_mutexattr_destroy(&attr);
	}
#endif
}

xEmutex::~xEmutex()
{
#ifdef _WIN32
	BOOL ret = CloseHandle(_mutex);
	if (0 != ret) {
		_mutex = NULL;
	}
#else
	pthread_mutex_destroy(&_mutex);
#endif
}

int32_t xEmutex::lock(uint32_t millisecond) {
#ifdef _WIN32
	if (NULL == _mutex) {
		return SEA_NULL_POINTER;
	}

	DWORD ret = WaitForSingleObject(_mutex, millisecond);
	if (WAIT_OBJECT_0 == ret) {
		return 0;
	}
	else if (WAIT_TIMEOUT == ret) {
		return SEA_TIMEOUT;
	}
	else {
		return SEA_SYSERROR;
	}
#else
	int32_t ret = 0;

	if (INFINITE == millisecond) {
		ret = pthread_mutex_lock(&_mutex);
	}
	else {
		struct timespec ts = {0, 0};
		get_abs_timespec(&ts, millisecond);
		ret = pthread_mutex_timedlock(&_mutex, &ts);
	}

	if (0 != ret) {
		int32_t e = errno;
		if (ETIMEDOUT == e) {
			return SEA_TIMEOUT;
		}
		else {
			return SEA_SYSERROR;
		}
	}
	return 0;
#endif
}

int32_t xEmutex::try_lock() {
#ifdef _WIN32
	return lock(1);
#else
	int32_t ret = 0;
	ret = pthread_mutex_trylock(&_mutex);
	return (0 == ret ? 0 : SEA_SYSERROR);
#endif
}

int32_t xEmutex::unlock() {
#ifdef _WIN32
	BOOL ret = FALSE;

	if (NULL != _mutex) {
		ret = ReleaseMutex(_mutex);
	}
	return (0 != ret ? 0 : SEA_SYSERROR);
#else
	int32_t ret = 0;
	ret = pthread_mutex_unlock(&_mutex);
	return (0 == ret ? 0 : SEA_SYSERROR);
#endif
} 

xSpinLock::xSpinLock()
{
#ifdef WIN32
	m_lock=0;
#else
	pthread_spin_init(&m_lock,0);
#endif

}
xSpinLock::~xSpinLock()
{
#ifdef WIN32
	
#else
	pthread_spin_destroy(&m_lock);
#endif
}
void xSpinLock::lock() const
{
#ifdef WIN32
	InterlockedExchange(&m_lock,0);
#else
	int RetCode = pthread_spin_lock(&m_lock);
#endif
}
void xSpinLock::release() const
{
#ifdef WIN32
	InterlockedExchange(&m_lock,1);
#else
	int RetCode = pthread_spin_unlock(&m_lock);
#endif
}
bool xSpinLock::tryLock() const
{
#ifdef WIN32
	return InterlockedExchange(&m_lock,1)!=0;
#else
	int RetCode = pthread_spin_trylock(&m_lock);
	if (RetCode == 0)
		return true;
	else
		return false;
#endif
}
/72             0           0     0     644     5235      `
#include "xEthreadpool.h"
using namespace SEABASE;
/*class xShareable*/
xShareable::xShareable() : m_count(0) { }

void xShareable::inc()
{
	xEAutoLock lock(&m_mutex);
	++m_count;
}
int32_t xShareable::dec()
{
	xEAutoLock lock(&m_mutex);
	if(m_count>0)
		--m_count;
	return m_count;
}
int32_t xShareable::get_count()
{
	xEAutoLock lock(&m_mutex);
	return m_count;
}

/* class xRunable*/

/*class xEthreadbase*/
xEthreadbase::xEthreadbase(xsmartPtr<xRunable>runner,bool detached )
	: m_use_functor(true),
	m_runfuncptr(runner),
	m_funcptr(NULL),
	m_func_arg(NULL),
	m_detached(detached),
	m_state(INIT),
	m_isstoped(false)
#ifdef _WIN32
	,_handle(NULL)
#endif
{ }

xEthreadbase::xEthreadbase(threadfunc_t func, void* arg , bool detached)
	: m_use_functor(false),
	m_funcptr(func),
	m_func_arg(arg),
	m_detached(detached),
	m_state(INIT),
	m_isstoped(false)
#ifdef WIN32
	,_handle(NULL)
#endif
{ }
xEthreadbase::~xEthreadbase()
{
	join();
	m_state=STOP;
}
bool xEthreadbase::start()
{
	if(INIT!=m_state)
		return false;
	//xAutoLock L(m_LockState);
#ifdef WIN32
	_handle = _beginthreadex(0,0,thread_proxy,this,0,&_thread_id);
#else
	int ret;
	pthread_attr_t attr;
	ret = pthread_attr_init(&attr);
	if (0 != ret) {
		return false;
	}
	int arg=0;
	pthread_create(&_thread_id,NULL,thread_proxy,this);
#endif
	//m_ConditionState.wait(m_LockState);
	m_sema.wait();
	m_state=START;
	return 0;

}
bool xEthreadbase::join()
{
	if(m_state!=START&&m_state!=STOP)
		return false;
#ifdef WIN32
	//WAIT_OBJECT ±íÊ¾Ö´ĞĞ½áÊø
	if(_handle!=0)
	{
		DWORD dw= WaitForSingleObject(reinterpret_cast<HANDLE>(_thread_id),INFINITE);
		if(WAIT_OBJECT_0==dw ||WAIT_ABANDONED == dw)
		{
			CloseHandle(reinterpret_cast<HANDLE>(_handle)); //ÊÍ·Å¾ä±ú×ÊÔ´£¬Ïß³Ì²¢Ã»ÓĞ½áÊø
			_handle=0;
			printf("\n join thread %d finish\n",_handle);
		}
	}
#else
	pthread_join(_thread_id,NULL);
#endif
	m_state = JOINED;
	return 0;
}
bool xEthreadbase::stop()
{
	bool ret = false;
	if (m_state != STOP && m_state >= START)
	{
		m_isstoped = true;
		m_state = STOP;
		ret = true;
	}
	return ret;
}
#ifdef WIN32
unsigned int xEthreadbase::get_thread_id() const
{
	return _thread_id;
}
size_t xEthreadbase::gethandle()
{
	return _handle;
}
#else
pthread_t xEthreadbase::get_thread_id() const
{
	return _thread_id;
}
#endif
#ifdef WIN32
unsigned int xEthreadbase::thread_proxy(void* arg)
#else
void* xEthreadbase::thread_proxy(void* arg)
#endif
{
	xEthreadbase*thread = (xEthreadbase*)arg;
	xsmartPtr<xRunable> runner=thread->m_runfuncptr;
	bool use_functor = thread->m_use_functor;
	threadfunc_t func = thread->m_funcptr;
	void *parg = thread->m_func_arg;
	thread->m_sema.signal();

	if(use_functor)	//Ê¹ÓÃÁËµÚÒ»ÖÖµÄ¹¹Ôìº¯Êı
	{
		if(runner.is_valid())
		{
			runner->Onrun(&thread->m_isstoped,arg);
		}
	}
	else
	{
		if(func)
		{
			func(&thread->m_isstoped,arg);
		}
	}
	return 0;
}

/* class threadgroup*/

xThreadGroup::xThreadGroup()
{

}
xThreadGroup::~xThreadGroup()
{

}
bool xThreadGroup::addThread(xsmartPtr<xEthreadbase>thread)
{
	try {
		m_threads.push_back(thread);
	} catch(std::bad_alloc& ) {
		return false;
	}
	return true;
}
bool xThreadGroup::join()
{
	citr_type citr;

	for (citr = m_threads.begin(); citr != m_threads.end(); ++citr) {
		(*citr)->join();
	}

	m_threads.clear();

	return true;
}
size_t xThreadGroup::size()
{
	return m_threads.size();
}
bool xThreadGroup::terminateAll()
{
	citr_type citr;

	for (citr = m_threads.begin(); citr != m_threads.end(); ++citr) {
		(*citr)->stop();
	}

	return true;
}

/* class xThreadPool*/
class xThreadPool::ThreadPoolRunner:public xRunable
{
public:
	ThreadPoolRunner(xThreadPool*tp);
	virtual int32_t Onrun(const bool * isstoped,void*param=NULL);
private:
	xThreadPool* _tp;
};
xThreadPool::ThreadPoolRunner::ThreadPoolRunner(xThreadPool*tp):_tp(tp)
{

}
int32_t xThreadPool::ThreadPoolRunner::Onrun(const bool * isstoped,void*param)
{
	while(!(*isstoped))
	{
		xRunable* prun=NULL;
		if(_tp->m_tasks.get(prun, INFINITE)==0&&prun){
			prun->Onrun(isstoped, param);
		}
	}
	return 0;
}
xThreadPool::xThreadPool():m_state(UNINITIALIZED)
{

}
xThreadPool::~xThreadPool()
{
	terninate();
}
//static const int DEFAULT_THREADS_NUM = 10; //Ä¬ÈÏÏß³ÌÊıÁ¿
int xThreadPool::init(int nThreads)
{
	int ret = 0;
	if (UNINITIALIZED == m_state) {
		m_state = INITIALIZED;

		addthread(nThreads);
	}

	return ret;
}
bool xThreadPool::addTask(xRunable* runinst)
{
	return 0 == m_tasks.put(runinst);
}
bool xThreadPool::join()
{
	 return m_threadgroup.join();
}
size_t xThreadPool::size()
{
	return m_threadgroup.size();
}
bool xThreadPool::terninate()
{
	return m_threadgroup.terminateAll();
}
int xThreadPool::addthread(int nthreads) {
	int ret = 0;
	for (int i = 0; i < nthreads; ++i) {
		xsmartPtr<xEthreadbase>workerThread =xsmartPtr<xEthreadbase>(new xEthreadbase(xsmartPtr<ThreadPoolRunner>(new ThreadPoolRunner(this))));
		if (workerThread.is_valid()) {
			workerThread->start();
			m_threadgroup.addThread(workerThread);
			++ret;
		}
	}
	return ret;
}
xReactor.cpp/   0           0     0     644     1997      `
//xjshi 2019/3/13 
//ÖØ¹¹hpp xReacotr.cpp

#include "xReactor.h"
using namespace SEABASE;
using namespace std;
xReactor::xReactor()
{
	m_reactorimp = new xReactorImplentation();

}
xReactor::~xReactor()
{
	if(m_reactorimp!=NULL)
	{
		delete m_reactorimp;
		m_reactorimp=NULL;
	}
}
int xReactor::RegisterHandler(xReceivebackbase*handler,SEABASE::handle_t&sockfd,int type)
{
	return m_reactorimp->RegisterHandler(handler,sockfd,type);
}

// int xReactor::RemoveHandler(xEventHandler* handler)
// {
// 	return m_reactorimp->RemoveHandler(handler);
// }
int xReactor::RemoveHandlerbyfd(SEABASE::handle_t handlefd)
{
	return m_reactorimp->RemoveHandlerbyfd(handlefd);
}
void xReactor::HandlerEvents()
{
	m_reactorimp->StartLoop();
}
int xReactor::RegisterTimeTask(xheaptimer* timerevent)
{
	m_reactorimp->RegisterTimeTask(timerevent);
	return 0;
}


int xReactorImplentation::RegisterHandler(xReceivebackbase*handler,SEABASE::handle_t&sockfd,int type)
{
	xEvent_t e;
	if(type==datatype::TcpAcceptCallback)
		Eventcallback::InitEvent(e,sockfd,handler,Eventcallback::AcceptCallback);
	else if(type==datatype::TcpDataCallback)
		Eventcallback::InitEvent(e,sockfd,handler,Eventcallback::DataCallback);
	return m_demultiplexer->RequestEvent(e);
}

int xReactorImplentation::RemoveHandlerbyfd(SEABASE::handle_t handlefd)
{
	return m_demultiplexer->UnrequestEvent(handlefd);
}
//ÕâÀïÌí¼ÓÊÂ¼şÑ­»·£¬
//Ìí¼Óstart
void xReactorImplentation::HandlerEvents()
{
	while(!_bIsstop)
	{
		int timeout = 1;
		if(m_eventtimer->top() ==NULL)
		{
			timeout = 1;
		}
		else
		{
			timeout = (m_eventtimer->top()->expire-time(NULL))*1000;
		}
		if(m_demultiplexer==NULL)
			return;
		m_demultiplexer->WaitEvents(timeout,m_eventtimer);

	}
}
int xReactorImplentation::RegisterTimeTask(xheaptimer* timerevent)
{
	if(timerevent == NULL)
		return -1;
	m_eventtimer->add_timer(timerevent);
	return 0;
}
xReactor* ReactorInstance::m_reactor=NULL;
xEtcpclient.cpp/0           0     0     644     648       `
#include "xEtcpclient.h"
using namespace  SEABASE;

int ExTcpClient::connectTCP(char*serverip,int serverport)
{
	strcpy(m_serverip,serverip);
	m_serverport=serverport;
	struct sockaddr_in tcpddr;
	tcpddr.sin_family=AF_INET;
	tcpddr.sin_addr.s_addr=inet_addr(m_serverip);
	tcpddr.sin_port=htons(m_serverport);
	return ConnectSocket(m_sockfd,(sockaddr*)&tcpddr,sizeof(struct sockaddr_in));
}
int ExTcpClient::recieve(char* buf,int len)
{
	return ReadSocket(m_sockfd,buf,len,0);

}
int ExTcpClient::sendMsg(char*buf,int len)
{
	return SendSocket(m_sockfd,buf,len);
}
int ExTcpClient::close()
{
	return CloseSocket(m_sockfd);
}